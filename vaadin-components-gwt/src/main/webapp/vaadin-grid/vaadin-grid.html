<!--
@element v-grid
-->

<link rel='import' href='vaadin-grid-import.html'>
<link rel='import' href='../bower_components/polymer/polymer.html'>
<link rel="stylesheet" href="vaadin-grid.css" shim-shadowdom>

<dom-module id="v-grid">
  <template>
  </template>
</dom-module>

<script>
  var prototype = {
    is: "v-grid",

    grid: undefined,

    properties: {
      /**
       * Declares the theme used for this grid instance. The grid does not load the custom theme CSS file,
       * it expects that the correct styles are provided by the current HTML page.
       *
       * If not specified, the default theme variation is used (loaded automatically by the HTML import).
       *
       * @attribute theme
       * @type String
       */
      theme: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * The columns array
       *
       * @attribute columns
       * @type array
       */
      columns: {
        type: Array,
        observer: 'columnsChanged'
      }
    },

    columnsChanged: function() {
      var oldcols = this.grid.getColumns();
      var newcols = this.columns;
      if (!oldcols._obs || newcols != oldcols) {
        if (oldcols._obs) {
          Polymer.ArrayObserve.unobserve(oldcols, oldcols._obs);
        }
        var _this = this;
        newcols._obs = function() {
          _this.grid.setColumns(newcols);
        }
        Polymer.ArrayObserve.observe(newcols, newcols._obs);
      }
      this.grid.setColumns(newcols);
    },

    attributeChanged: function(name, type, value) {
      switch (name) {
        case 'selected-rows':
          this.selectedRows = /^\[.*\]$/.test(value) ? JSON.parse(value) : value.split(/[, ]+/)
          .map(function(x) {
            return parseInt(x, 10);
          }).filter(function(x) {
            return !isNaN(x);
          });
          break;
        case 'disabled':
          this.disabled = typeof value == "string";
          break;
        case 'editable':
          this.editable = typeof value == "string";
          break;
        case 'style':
          this.grid.redraw();
          break;
        default:
          this[Polymer.CaseMap.dashToCamelCase(name)] = value;
      }
    },

    listeners: {
      /**
       * @event sort
       */
      /**
       * @event select
       */
      'select': 'onSelect'
    },

    onSelect: function() {
      this.setAttribute('selected-rows', this.selectedRows.join());
    },

    ready: function() {
      this.grid = new vaadin.GridComponent();
      this.grid.init(this, Polymer.dom(this).querySelector("table"), Polymer.dom(this.root));

      var _this = this;
      this.editor = {
        get enabled() {
          return _this.grid.getEditor().isEnabled();
        },
        set enabled(enabled) {
          _this.grid.getEditor().setEnabled(enabled);
          if (_this.editable !== enabled) {
            _this.editable = enabled;
          }
        },
        get handler() {
          return _this.grid.getEditor().getHandler();
        },
        set handler(handler) {
          _this.grid.getEditor().setHandler(handler);
        },
        get saveButtonText() {
          return _this.grid.getEditor().getSaveButtonText();
        },
        set saveButtonText(saveButtonText) {
          _this.grid.getEditor().setSaveButtonText(saveButtonText);
        },
        get cancelButtonText() {
          return _this.grid.getEditor().getSaveButtonText();
        },
        set cancelButtonText(cancelButtonText) {
          _this.grid.getEditor().setCancelButtonText(cancelButtonText);
        },
        editRow: function(row) {
          _this.grid.getEditor().editRow(row);
        },
        save: function() {
          _this.grid.getEditor().save();
        },
        cancel: function() {
          _this.grid.getEditor().cancel();
        }

      };

      this.data = {

        get source() {
          return this._source;
        },
        set source(source) {
          var sourceFunction = source;
          if (Array.isArray(source)) {
            sourceFunction = function(req) {
              var array = source.slice(req.index, req.index + req.count);
              req.success(array, source.length);
            };
          }
          _this.grid.setDataSource(sourceFunction);

          this._source = source;
        },

        dataUpdated: function(firstIndex, itemsData) {
          _this.grid.getDataSource().dataUpdated(firstIndex, itemsData);
        },
        dataRemoved: function(firstIndex, numberOfItems) {
          _this.grid.getDataSource().dataRemoved(firstIndex, numberOfItems);
        },
        dataAdded: function(firstIndex, numberOfItems) {
          _this.grid.getDataSource().dataAdded(firstIndex, numberOfItems);
        },
        resetData: function(estimatedNewSize) {
          _this.grid.getDataSource().resetData(estimatedNewSize);
        },

      };

      this.header = {
        getCell: function(rowIndex, columnId) {
          return _this.grid.getStaticSection().getHeaderCell(rowIndex, columnId);
        },
        addRow: function(rowIndex, cellContent) {
          _this.grid.getStaticSection().addHeader(rowIndex, cellContent);
        },
        removeRow: function(rowIndex) {
          _this.grid.getStaticSection().removeHeader(rowIndex);
        },
        setRowClassName: function(rowIndex, className) {
          _this.grid.getStaticSection().setHeaderRowClassName(rowIndex, className);
        },
        /**
         * Sets the default row of the header. The default row is a special header
         * row providing a user interface for sorting columns.
         *
         * @attribute rowIndex
         * @type number
         */
        get defaultRow() {
          return _this.grid.getStaticSection().getDefaultHeader();
        },
        set defaultRow(rowIndex) {
          _this.grid.getStaticSection().setDefaultHeader(rowIndex);
        },
        get hidden() {
          return _this.grid.getStaticSection().isHeaderHidden();
        },
        set hidden(hidden) {
          _this.grid.getStaticSection().setHeaderHidden(hidden);
        }

      };

      this.footer = {
        getCell: function(rowIndex, columnId) {
          return _this.grid.getStaticSection().getFooterCell(rowIndex, columnId);
        },
        addRow: function(rowIndex, cellContent) {
          _this.grid.getStaticSection().addFooter(rowIndex, cellContent);
        },
        removeRow: function(rowIndex) {
          _this.grid.getStaticSection().removeFooter(rowIndex);
        },
        setRowClassName: function(rowIndex, className) {
          _this.grid.getStaticSection().setFooterRowClassName(rowIndex, className);
        },
        get hidden() {
          return _this.grid.getStaticSection().isFooterHidden();
        },
        set hidden(hidden) {
          _this.grid.getStaticSection().setFooterHidden(hidden);
        }
      };

      // Set read-only properties
      ["data", "editor", "header", "footer"].forEach(function(prop) {
        Object.defineProperty(_this, prop, {
          writable: false
        });
      });

      Object.defineProperty(this, 'scrollTop', {
        get: function() {
          return this.grid.getScrollTop();
        },
        set: function(newValue) {
          this.grid.setScrollTop(newValue);
          return this;
        },
        enumerable: true,
        configurable: false
      });

      setTimeout(function() {
        for (var i = 0; i < _this.attributes.length; i++) {
          _this.attributeChanged(_this.attributes[i].nodeName, null, _this.attributes[i].nodeValue);
        }
      }, 1);

      _this.columns = _this.grid.getColumns();
    },

    /**
     * Scrolls to a certain row, using user-specified scroll destination.
     * Since its asynchronous nature, this method returns a 'thenable'
     * so as you can use the 'then()' method to be notified when the data
     * request finished and the scroll is actually moved.
     *
     * @method scrollToRow
     * @param {number} index - zero-based index of the row to scroll to.
     * @param {string} scrollDestination - desired destination placement of scrolled-to-row.
     */
    scrollToRow: function(index, scrollDestination) {
      this.grid.scrollToRow(index, scrollDestination);
      return this;
    },

    /**
     * Scrolls to the beginning of the very first row.
     * Since its asynchronous nature, this method returns a 'thenable'
     * so as you can use the 'then()' method to be notified when the data
     * request finished and the scroll is actually moved.
     *
     * @method scrollToStart
     */
    scrollToStart: function() {
      this.grid.scrollToStart();
      return this;
    },

    /**
     * Scrolls to the end of the very last row.
     * Since its asynchronous nature, this method returns a 'thenable'
     * so as you can use the 'then()' method to be notified when the data
     * request finished and the scroll is actually moved.
     *
     * @method scrollToEnd
     */
    scrollToEnd: function() {
      this.grid.scrollToEnd();
      return this;
    },

    /**
     * Selects certain row
     *
     * @method select
     * @param {Object} value
     */
    select: function(value) {
      var array = this.selectedRows;
      if (array.indexOf(value) == -1) {
        array.push(value);
        this.selectedRows = array;
      }
    },

    /**
     * Deselects certain row
     *
     * @method deselect
     * @param {Object} value
     */
    deselect: function(value) {
      var array = this.selectedRows;
      var index = array.indexOf(value);
      if (index > -1) {
        array.splice(index, 1);
        this.selectedRows = array;
      }
    },

    /**
     * Adds new column
     *
     * @method addColumn
     * @param {Object} column
     * @param {string} beforeColumn
     */
    addColumn: function(column, beforeColumn) {
      this.grid.addColumn(column, beforeColumn);
    },

    /**
     * Removes column with certain id
     *
     * @method removeColumn
     * @param {string} id
     */
    removeColumn: function(id) {
      this.grid.removeColumn(id);
    },

    /**
     * The selected rows array
     *
     * @attribute selectedRows
     * @type array
     */
    set selectedRows(r) {
      return this.grid.setSelectedRows(r);
    },
    get selectedRows() {
      return this.grid.getSelectedRows();
    },

    /**
     * Sets the sort order to use. Setting this causes the Grid to re-sort
     * itself. If set to null, the sort order is cleared.
     *
     * @attribute sortOrder
     * @type array
     */
    get sortOrder() {
      return this.grid.getSortOrder();
    },
    set sortOrder(sortOrder) {
      this.grid.setSortOrder(sortOrder);
    },
    /**
     * Sets the style generator that is used for generating styles for rows.
     *
     * @attribute rowClassName
     * @type object
     */
    get rowClassName() {
      return this.grid.getRowClassName();
    },
    set rowClassName(rowClassName) {
      this.grid.setRowClassName(rowClassName);
    },
    /**
     * Sets the style generator that is used for generating styles for cells.
     *
     * @attribute cellClassName
     * @type object
     */
    get cellClassName() {
      return this.grid.getCellClassName();
    },
    set cellClassName(cellClassName) {
      this.grid.setCellClassName(cellClassName);
    },
    /**
     * Declares the selection model of the Grid to one of the built-in/preconfigured selection modes.
     *
     * @attribute selection-mode
     * @type String
     */
    get selectionMode() {
      return this.grid.getSelectionMode();
    },
    set selectionMode(selectionMode) {
      this.grid.setSelectionMode(selectionMode);
      this.reflectPropertyToAttribute("selectionMode");
    },
    /**
     * Disables the grid functionality.
     *
     * @attribute disabled
     * @type boolean
     */
    get disabled() {
      return this.grid.isDisabled();
    },
    set disabled(disabled) {
      this.grid.setDisabled(selectionMode);
      this.reflectPropertyToAttribute("disabled");
    },
    /**
     * Enables the row editor feature (double click/tap or or Enter key in a content row activates the editing mode)
     *
     * @attribute editable
     * @type boolean
     */
    get editable() {
      return this.editor.enabled;
    },
    set editable(editable) {
      this.editor.enabled = editable;
      this.reflectPropertyToAttribute("editable");
    },
    /**
     * Sets the number of frozen columns in this grid. Setting the count to 0
     * means that no data columns will be frozen, but the built-in selection
     * checkbox column will still be frozen if it's in use. Setting the count to
     * -1 will also disable the selection column.
     *
     * @attribute frozen-columns
     * @type Number
     */
    get frozenColumns() {
      return this.grid.getFrozenColumns();
    },
    set frozenColumns(frozenColumns) {
      this.grid.setFrozenColumns(frozenColumns);
      this.reflectPropertyToAttribute("frozenColumns");
    },
    /**
     * Declares the number of visible rows in the grid. Implicitly sets the height
     * in the inline style, overriding any previous height. Setting style.height
     * in this case should be ignored if possible.
     *
     * @attribute rows
     * @type Number
     */
    get rows() {
      return this.grid.getRows();
    },
    set rows(rows) {
      this.grid.setRows(rows);
      this.reflectPropertyToAttribute("rows");
    },
    then: function(cb) {
      return this.grid.then(cb);
    }
  };

  function loadComponent() {
    VGrid = Polymer(prototype);
    // Give some time to gwt async processes to run (we need this in FF)
    setTimeout(function() {
      vaadin._v_grid_ready = true;
      document.dispatchEvent(new Event('v-grid-ready'));
    }, 5);
  }

  if (window.vaadin && window.vaadin.GridComponent) {
    loadComponent();
  } else {
    document.addEventListener("v-grid-loaded", function() {
      loadComponent();
    });
  }
</script>
