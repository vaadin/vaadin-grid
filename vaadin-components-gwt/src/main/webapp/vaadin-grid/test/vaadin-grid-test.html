<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <script>
    PolymerSettings = {
      //shadow: true
    };
  </script>

  <script src="../../../bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <script src="../../../bower_components/web-component-tester/browser.js"></script>
  <link rel="import" href="../../../bower_components/polymer/src/expr/polymer-expr.html">
  <script src="../../VaadinGrid/VaadinGrid.nocache.js"></script>
  <link rel="import" href="../vaadin-grid.html">
</head>

<body>
  <script>
    function waitUntilGridReady(cb) {
      if (window.vaadin && vaadin._v_grid_ready) {
        cb();
      } else {
        document.addEventListener("v-grid-ready", function() {
          cb();
        });
      }
    }

    function waitUntil(check, exec, onTimeout) {
      var id = setInterval(function() {
        if (check()) {
          clearInterval(id);
          clearTimeout(timeoutId);
          exec();
        }
      }, 100);

      var timeoutId = setTimeout(function() {
        clearInterval(id);
        assert.fail();
        onTimeout();
      }, 5000);
    }
  </script>

  <div id="gridwrapper"></div>

  <script>
    suite('vaadin-grid', function() {
      var grid, wrapper;

      function removeGrid() {
        if (grid) {
          grid.style.visibility = "hidden";
          document.body.appendChild(grid);
          grid = null;
        }
      }

      var infiniteDataSource = function(req) {
        var data = [];
        for (var i = req.index; i < req.index + req.count; i++) {
          data.push(["foo " + i, "bar " + i]);
        }
        req.success(data, this.size);
      };

      var gridContainsText = function(_grid, text) {
        return Polymer.dom(_grid.root).querySelector(".v-grid").innerHTML.indexOf(text) > -1;
      };

      var local = function() {
        return Polymer.dom(grid.root);
      };
      var light = function() {
        return Polymer.dom(grid);
      };

      var qLocal = function(selector) {
        return local().querySelector(selector);
      };
      var qaLocal = function(selector) {
        return local().querySelectorAll(selector);
      };
      var qLight = function(selector) {
        return light().querySelector(selector);
      };

      var editorHandler = {
        getCellEditor: function(columnObject) {
          var input = document.createElement("input");
          return input;
        },
        bind: function(req) {
          for (var i = 0; i < req.grid.columns.length; i++) {
            var col = req.grid.columns[i];
            if (!col.readOnly) {
              var el = req.getCellEditor(col);
              el.value = req.dataItem[i];
            }
          }
          req.success();
        },
        save: function(req) {
          var failingColumns = [];
          for (var i = 0; i < req.grid.columns.length; i++) {
            var col = req.grid.columns[i];
            var el = req.getCellEditor(col);
            if (el.value == "fail") {
              failingColumns.push(col);
            }
          }
          if (failingColumns.length > 0) {
            req.failure("Save failed", failingColumns);
          } else {
            req.success();
          }
        }
      };

      setup(function(done) {
        removeGrid();

        wrapper = document.getElementById("gridwrapper");
        wrapper.innerHTML = "<v-grid><table><thead><tr><th>Name</th><th>Value</th></tr></thead>" +
          "<tbody><tr><td>Grid</td><td>10000</td></tr><tr><td>VaadinX</td><td>1000</td></tr></tbody></table></v-grid>";
        grid = wrapper.querySelector("v-grid");

        waitUntilGridReady(function() {
          // in each iteration we need to sleep a while so as all
          // asynchronous processes in the grid initialization finish
          setTimeout(done, 200);
        });
      });

      test('light dom table header gets rendered in the grid', function() {
        var row = qLocal(".v-grid-header .v-grid-row");
        var cells = row.childNodes;

        assert.isTrue(cells[0].innerHTML == 'Name');
        assert.isTrue(cells[1].innerHTML == 'Value');
      });

      test('light dom table body gets rendered in the grid', function() {
        var row = qLocal(".v-grid-body .v-grid-row");
        var cells = row.childNodes;

        assert.isTrue(cells[0].innerHTML == 'Grid');
        assert.isTrue(cells[1].innerHTML == '10000');
      });

      test('row declarative select', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        grid.setAttribute("selected-rows", "0");
        assert.ok(qLocal(".v-grid-body .v-grid-row-selected"));
        grid.setAttribute("selected-rows", "");
        assert.notOk(qLocal(".v-grid-body .v-grid-row-selected"));

        assert.equal(spy.callCount, 2);
      });

      test('row click select', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        var cell = qLocal(".v-grid-body .v-grid-cell");
        cell.click();
        assert.equal(grid.getAttribute("selected-rows"), "0");
        cell.click();
        assert.isTrue(grid.getAttribute("selected-rows") === "");

        assert.equal(spy.callCount, 2);
      });

      test('switch between selection modes: property', function() {
        var checkBoxQuery = "input[type='checkbox']";

        grid.selectionMode = "single";
        assert.equal(grid.getAttribute("selection-mode"), "single");
        assert.notOk(qLocal(checkBoxQuery));

        grid.selectionMode = "multi";
        assert.equal(grid.getAttribute("selection-mode"), "multi");
        var checkBoxes = qaLocal(checkBoxQuery);
        assert.isTrue(checkBoxes.length > 0);

        grid.selectionMode = "none";
        assert.equal(grid.getAttribute("selection-mode"), "none");
        assert.notOk(qLocal(checkBoxQuery));
      });

      test('switch between selection modes: attribute', function() {
        var checkBoxQuery = "input[type='checkbox']";

        grid.setAttribute("selection-mode", "single");
        var cellQuery = ".v-grid-body .v-grid-cell";
        qLocal(cellQuery).click();
        assert.equal(grid.selectionMode, "single");
        expect(grid.selectedRows).to.eql([0]);

        grid.setAttribute("selection-mode", "multi");
        assert.equal(grid.selectionMode, "multi");

        grid.setAttribute("selection-mode", "none");
        assert.equal(grid.selectionMode, "none");
      });

      test('selected rows: single', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        var rowQuery = ".v-grid-body .v-grid-row";
        var selectedStyle = "v-grid-row-selected";

        grid.selectionMode = "single";
        grid.selectedRows = [1];
        assert.equal(grid.getAttribute("selected-rows"), "1");
        var rows = qaLocal(rowQuery);
        assert.isFalse(rows[0].classList.contains(selectedStyle));
        assert.isTrue(rows[1].classList.contains(selectedStyle));
        grid.selectedRows = "";
        assert.equal(qaLocal(rowQuery + "." + selectedStyle).length, 0);

        grid.setAttribute("selected-rows", "0");
        expect(grid.selectedRows).to.eql([0]);
        grid.setAttribute("selected-rows", "");
        expect(grid.selectedRows).to.be.empty;

        var cellQuery = ".v-grid-body .v-grid-cell";
        qLocal(cellQuery).click();
        expect(grid.selectedRows).to.eql([0]);

        assert.equal(spy.callCount, 5);
      });

      test('selected rows: multi', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        var rowQuery = ".v-grid-body .v-grid-row";
        var selectedStyle = "v-grid-row-selected";

        grid.selectionMode = "multi";
        grid.selectedRows = "0,1";
        assert.equal(grid.getAttribute("selected-rows"), "0,1");
        var rows = qaLocal(rowQuery);
        assert.isTrue(rows[0].classList.contains(selectedStyle));
        assert.isTrue(rows[1].classList.contains(selectedStyle));
        grid.selectedRows = "0";
        assert.equal(qaLocal(rowQuery + "." + selectedStyle).length, 1);

        grid.setAttribute("selected-rows", "0,1");
        expect(grid.selectedRows).to.eql([0, 1]);
        grid.setAttribute("selected-rows", "");
        expect(grid.selectedRows).to.be.empty;

        // TODO: Select in UI
        assert.equal(spy.callCount, 4);
      });

      test('select function', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        grid.selectionMode = "multi";
        grid.select(0);
        grid.select(1);
        expect(grid.selectedRows).to.eql([0, 1]);

        grid.selectionMode = "single";
        expect(grid.selectedRows).to.be.empty;

        grid.select(0);
        grid.select(1);
        expect(grid.selectedRows).to.eql([1]);

        grid.select(2);
        assert.equal(1, grid.selectedRows[0]);

        assert.equal(spy.callCount, 4);
      });

      test('selected rows before data iterations', function(done) {
        removeGrid(grid);

        var wrapper = document.getElementById("gridwrapper");
        wrapper.innerHTML = "<v-grid><table><thead><tr><th>Name</th><th>Value</th></tr></thead>" +
          "<tbody><tr><td>Grid</td><td>10000</td></tr><tr><td>VaadinX</td><td>1000</td></tr></tbody></table></v-grid>";
        grid = wrapper.querySelector("v-grid");

        grid.selectionMode = "multi";
        grid.selectedRows = [1];

        waitUntil(function() {
          return gridContainsText(grid, "VaadinX");
        }, function() {
          expect(grid.selectedRows).to.eql([1]);
          done();
        }, done);
      });

      test('selected rows before data iterations 2', function() {
        var wrapper = document.getElementById("gridwrapper");

        var _grid = grid;
        _grid.style.visibility = "hidden";
        document.body.appendChild(_grid);

        wrapper.innerHTML = "<v-grid><table><thead><tr><th>Name</th><th>Value</th></tr></thead>" +
          "<tbody><tr><td>Grid</td><td>10000</td></tr><tr><td>VaadinX</td><td>1000</td></tr></tbody></table></v-grid>";
        grid = wrapper.querySelector("v-grid");

        grid.selectionMode = "multi";
        grid.selectedRows = [0, 1];

        //In this case the indices are still cached to selection model
        expect(grid.selectedRows).to.eql([0, 1]);
      });



      test('deselect function', function() {
        var spy = sinon.spy();
        grid.addEventListener("select", spy);

        grid.selectionMode = "multi";
        grid.selectedRows = [0, 1];
        grid.deselect(0);
        expect(grid.selectedRows).to.eql([1]);

        grid.deselect(1);
        expect(grid.selectedRows).to.be.empty;

        grid.selectedRows = [0, 1];
        grid.deselect(2);
        expect(grid.selectedRows).to.eql([0, 1]);

        grid.selectionMode = "single";
        grid.select(1);
        grid.deselect(0);
        expect(grid.selectedRows).not.to.be.empty;
        grid.deselect(1);
        expect(grid.selectedRows).to.be.empty;

        assert.equal(spy.callCount, 6);
      });

      test('scrollToRow function', function(done) {
        infiniteDataSource.size = 100;
        grid.data.source = infiniteDataSource;

        expect(grid.scrollToRow.bind(grid, -10)).to.throw("Row index");

        waitUntil(function() {
          return gridContainsText(grid, "foo 0");
        }, function() {
          assert.isFalse(gridContainsText(grid, "foo 50"));

          grid.scrollToRow(50);

          waitUntil(function() {
            return gridContainsText(grid, "foo 50");
          }, function() {
            assert.isFalse(gridContainsText(grid, "foo 0"));
            expect(grid.scrollToRow.bind(grid, 100)).to.throw("Row index");

            done();
          }, done);
        }, done);
      });

      test('scrollToRow with destination', function(done) {
        infiniteDataSource.size = 100;
        grid.data.source = infiniteDataSource;

        waitUntil(function() {
          return gridContainsText(grid, "foo 0");
        }, function() {
          grid.scrollToRow(50, "start");

          waitUntil(function() {
            return gridContainsText(grid, "foo 50");
          }, function() {

            assert.isTrue(gridContainsText(grid, "foo 52"));
            assert.isFalse(gridContainsText(grid, "foo 49"));

            grid.scrollToRow(70, "end");

            waitUntil(function() {
              return gridContainsText(grid, "foo 70");
            }, function() {
              assert.isFalse(gridContainsText(grid, "foo 72"));
              assert.isTrue(gridContainsText(grid, "foo 69"));

              done();
            }, done);
          }, done);


        }, done);
      });

      test('scrollToStart and scrollToEnd functions', function(done) {
        infiniteDataSource.size = 100;
        grid.data.source = infiniteDataSource;

        waitUntil(function() {
          return gridContainsText(grid, "foo 0");
        }, function() {

          grid.scrollToEnd();

          waitUntil(function() {
            return gridContainsText(grid, "foo 99");
          }, function() {

            grid.scrollToStart();

            waitUntil(function() {
              return gridContainsText(grid, "foo 0");
            }, done, done);
          }, done);
        }, done);
      });

      test('scrollTop property', function(done) {
        infiniteDataSource.size = 100;
        grid.data.source = infiniteDataSource;

        assert.equal(grid.scrollTop, 0);

        waitUntil(function() {
          return gridContainsText(grid, "foo 0");
        }, function() {

          grid.scrollToRow(1, "start");

          var rowHeight = grid.scrollTop;
          expect(rowHeight).to.be.above(0);

          grid.scrollToRow(50, "start");
          waitUntil(function() {
            return gridContainsText(grid, "foo 50");
          }, function() {
            assert.equal(grid.scrollTop, rowHeight * 50);

            done();
          }, done);
        }, done);
      });

      test('theme property', function() {
        grid.theme = "foo";
        assert.equal(grid.getAttribute("theme"), "foo");

        grid.setAttribute("theme", "bar");
        assert.equal(grid.theme, "bar");
      });

      test('sortOrder property', function() {
        grid.sortOrder = [];
        assert.lengthOf(grid.sortOrder, 0);

        grid.sortOrder = [{
          column: 0,
          direction: "desc"
        }];

        assert.lengthOf(grid.sortOrder, 1);
        var sortOrder = grid.sortOrder[0];
        assert.equal(sortOrder.column, 0);
        assert.equal(sortOrder.direction, "desc");

        grid.sortOrder = [];
        assert.lengthOf(grid.sortOrder, 0);

        var assignInvalidSortOrder = function() {
          grid.sortOrder = [{
            column: 0,
            direction: "ascending"
          }];
        };
        expect(assignInvalidSortOrder).to.throw("Invalid sort direction");
        assert.lengthOf(grid.sortOrder, 0);

        grid.sortOrder = [{
          column: 0,
          direction: "asc"
        }, {
          column: 1
        }];
        assert.lengthOf(grid.sortOrder, 2);
        assert.equal(grid.sortOrder[1].direction, "asc");
      });

      test('add new column', function() {
        grid.addColumn({
          name: "foo",
          headerHtml: "<b>Foo</b>",
          sortable: true,
          minWidth: "100px",
          maxWidth: "200px",
          width: "150px",
          flex: 1,
        });

        var c = grid.columns[grid.columns.length - 1];
        assert.equal(c.name, "foo");
        assert.equal(c.headerHtml, "<b>Foo</b>");
        assert.equal(c.sortable, true);
        assert.notOk(c.editable);
        assert.equal(c.minWidth, "100px");
        assert.equal(c.maxWidth, "200px");
        assert.equal(c.width, "150px");
        assert.equal(c.flex, 1);
      });

      test('add new column before', function(done) {

        expect(grid.addColumn.bind(grid, {
          name: "foo"
        }, -1)).to.throw("Column not found.");

        expect(grid.addColumn.bind(grid, {
          name: "foo"
        }, 100)).to.throw("Column not found.");

        grid.addColumn({
          name: "foo",
          headerHtml: "foo"
        }, 0);
        grid.addColumn({
          name: "bar",
          headerHtml: "testHtml"
        }, "foo");

        waitUntil(function() {
          return gridContainsText(grid, "testHtml");
        }, function() {
          var headers = qaLocal(".v-grid-header .v-grid-row th");
          assert.equal(headers[0].innerHTML, "testHtml");
          assert.equal(headers[1].innerHTML, "foo");

          expect(grid.addColumn.bind(grid, {
            name: "baz"
          }, "foobar")).to.throw("Column not found.");
          done();
        }, done);

      });

      test('edit new column', function(done) {
        var c = {
          name: "foo",
          headerHtml: "testHtml"
        };
        grid.addColumn(c);

        waitUntil(function() {
          return gridContainsText(grid, "testHtml");
        }, function() {

          var headers = qaLocal(".v-grid-header .v-grid-row th");
          assert.equal(headers[grid.columns.length - 1].innerHTML, "testHtml");

          c.headerHtml = "testHtml2";

          waitUntil(function() {
            return gridContainsText(grid, "testHtml2");
          }, function() {
            assert.equal(headers[grid.columns.length - 1].innerHTML, "testHtml2");
            done();
          }, done);

        }, done);

      });

      test('edit existing column', function(done) {
        grid.columns[0].headerHtml = "testHtml";
        waitUntil(function() {
          return gridContainsText(grid, "testHtml");
        }, function() {
          var headers = qaLocal(".v-grid-header .v-grid-row th");
          assert.equal(headers[0].innerHTML, "testHtml");
          done();
        });
      });

      test('generated value', function(done) {
        grid.addColumn({
          generatedValue: function(dataItem) {
            return "foo " + dataItem[0];
          }
        });

        waitUntil(function() {
          return gridContainsText(grid, "foo Grid");
        }, done, done);
      });

      test('renderer property', function(done) {
        grid.columns[0].renderer = function(cell) {
          cell.element.innerHTML = "<b>" + cell.data + "</b>";
        };

        waitUntil(function() {
          return gridContainsText(grid, "<b>Grid</b>");
        }, done, done);
      });

      test('renderer: cell values on change', function(done) {
        var mydata = [
          ["John", "TestFoo"],
          ["Jane", "TestBar"],
        ];

        grid.data.source = mydata;

        grid.columns[1].renderer = function(cell) {
          cell.element.innerHTML = cell.data;
          cell.element.cell = cell;
        };

        waitUntil(function() {
          return gridContainsText(grid, "TestFoo");
        }, function() {
          var cell = grid.querySelectorAll(".v-grid-body .v-grid-cell")[3].cell;
          assert.equal(cell.rowIndex, 1);
          assert.equal(cell.index, 1);

          mydata.splice(0, 1);
          mydata[0].splice(0, 1);
          grid.data.dataRemoved(0, 1);

          grid.columns.splice(0, 1);
          waitUntil(function() {
            return !gridContainsText(grid, "TestFoo");
          }, function() {
            assert.equal(cell.rowIndex, 0);
            assert.equal(cell.index, 0);
            done();
          }, done);
        }, done);

      });

      test('initial property values', function() {
        assert.equal(grid.columns[0].headerHtml, "Name");
      });

      test('modify columns array', function(done) {
        var col = grid.columns[0];
        grid.columns.splice(1, 1);

        waitUntil(function() {
          return !gridContainsText(grid, "Progress");
        }, function() {
          grid.columns.push({
            headerHtml: "testHtml"
          });
          waitUntil(function() {
            return gridContainsText(grid, "testHtml");
          }, done, done);
        }, done);
      });

      test('remove column', function(done) {
        grid.addColumn({
          name: "test",
          headerHtml: "test"
        });
        grid.removeColumn(0);

        waitUntil(function() {
          return !gridContainsText(grid, "Name") && gridContainsText(grid, "test");
        }, function() {
          grid.removeColumn("test");
          waitUntil(function() {
            return !gridContainsText(grid, "test");
          }, done, done);
        }, done);
      });

      test('add new column to an empty grid', function(done) {
        removeGrid();
        wrapper.innerHTML = "<v-grid></v-grid>";
        grid = wrapper.querySelector("v-grid");

        waitUntil(function() {
          return qLocal(".v-grid-body");
        }, function() {
          grid.columns.push({
            name: "foo",
            headerHtml: "fooheader"
          });

          waitUntil(function() {
            return gridContainsText(grid, "fooheader");
          }, done, done);
        }, done);

      });

      test('frozen column', function(done) {
        grid.frozenColumns = 1;

        waitUntil(function() {
          return gridContainsText(grid, "v-grid-cell frozen");
        }, function() {
          var headers = qaLocal(".v-grid-header .v-grid-row th");
          assert.isTrue(headers[0].classList.contains("frozen"));
          done();
        }, done);

      });

      test('frozen column: unfreeze selection column', function() {
        grid.selectionMode = "multi";
        assert.ok(qLocal(".frozen"));

        grid.frozenColumns = -1;
        assert.notOk(qLocal(".frozen"));
      });

      test('rowClassName', function() {
        var gridEquals = true;
        var elementEquals = true;
        assert.notOk(grid.rowClassName);
        var rowClassName = function(row) {
          gridEquals = gridEquals && row.grid == grid;
          elementEquals = elementEquals && row.element == qaLocal(".v-grid-body .v-grid-row")[row.index];
          return row.index + "_" + row.data[0];
        };

        grid.rowClassName = rowClassName;

        assert.isTrue(elementEquals && gridEquals);
        assert.isTrue(qLocal(".v-grid-body .v-grid-row").classList.contains("0_Grid"));
        assert.equal(grid.rowClassName, rowClassName);
      });

      test('cellClassName', function() {
        var elementEquals = true;

        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        assert.notOk(grid.cellClassName);
        var cellClassName = function(cell) {
          var columnIndex = cell.columnName == "name" ? 0 : 1;
          var cellElement = qaLocal(".v-grid-body .v-grid-row")[cell.row.index].querySelectorAll(".v-grid-cell")[columnIndex];
          elementEquals = elementEquals && cell.element == cellElement;
          return cell.columnName;
        };

        grid.cellClassName = cellClassName;

        assert.isTrue(elementEquals);
        assert.isTrue(qLocal(".v-grid-body .v-grid-row .v-grid-cell").classList.contains("name"));
        assert.equal(grid.cellClassName, cellClassName);
      });

      test('editor: enabled', function() {
        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        grid.editor.handler = editorHandler;
        expect(grid.editor.editRow.bind(grid.editor, 0)).to.throw("editor is not enabled");
        grid.editor.enabled = true;
        grid.editor.editRow(0);

        assert.isTrue(gridContainsText(grid, "v-grid-editor"));
      });

      test('editor: saveButtonText and cancelButtonText', function() {
        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        grid.editor.handler = editorHandler;
        grid.editor.enabled = true;
        grid.editor.editRow(0);
        grid.editor.saveButtonText = "saveButtonTextFoo";
        grid.editor.cancelButtonText = "cancelButtonTextFoo";

        assert.isTrue(gridContainsText(grid, "saveButtonTextFoo"));
        assert.isTrue(gridContainsText(grid, "cancelButtonTextFoo"));
      });

      test('editor: editrow', function() {
        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        grid.editor.handler = editorHandler;
        grid.editor.enabled = true;

        grid.editor.editRow(0);
        assert.equal(qLocal(".v-grid-editor input").value, "Grid");
        grid.editor.cancel();
        assert.isFalse(gridContainsText(grid, "v-grid-editor"));
        grid.editor.editRow(1);
        assert.equal(qLocal(".v-grid-editor input").value, "VaadinX");
        grid.editor.save();
        assert.isFalse(gridContainsText(grid, "v-grid-editor"));

        expect(grid.editor.editRow.bind(grid.editor, 10)).to.throw("Row index");
      });

      test('editor: failure', function() {
        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        grid.editor.handler = editorHandler;
        grid.editor.enabled = true;

        grid.editor.editRow(0);
        var fields = qaLocal(".v-grid-editor input");
        fields[0].value = "fail";
        grid.editor.save();

        assert.isTrue(gridContainsText(grid, "Save failed"));
        var cells = qaLocal(".v-grid-editor-cells > div");
        assert.isTrue(cells[0].classList.contains("error"));
        assert.isFalse(cells[1].classList.contains("error"));

      });

      test('editor: return null cell editor', function() {
        grid.columns[0].name = "name";
        grid.columns[1].name = "value";
        grid.editor.handler = {
          getCellEditor: function(columnObject) {
            return columnObject === grid.columns[0] ? null : undefined;
          },
          bind: function(req) {
            req.success();
          }
        };
        grid.editor.enabled = true;

        grid.editor.editRow(0);
        var cells = qaLocal(".v-grid-editor .v-grid-editor-cells > div");
        assert.lengthOf(cells, 2);

        var editors = qaLocal(".v-grid-editor .v-grid-editor-cells > div *");
        assert.lengthOf(editors, 0);
      });

      test('editor: element instance after save', function() {
        grid.editor.enabled = true;
        grid.editor.handler = editorHandler;

        var editor1, editor2;
        editorHandler.save = function(req) {
          if (!editor1) {
            editor1 = req.getCellEditor(grid.columns[0]);
            req.failure();
          } else {
            editor2 = req.getCellEditor(grid.columns[0]);
            req.success();
          }
        };
        grid.editor.editRow(0);

        //Save fails
        grid.editor.save();
        //Save succeeds
        grid.editor.save();

        assert.equal(editor1, editor2);
      });

      test('data: object type', function(done) {
        grid.columns[0].name = "firstname";
        grid.columns[1].name = "lastname";
        grid.columns.push({
          name: 'salary',
          headerHtml: "Salary"
        });

        var mydata = [{
          firstname: "John",
          lastname: "Doe",
          salary: 1234.56
        }, {
          firstname: "Jane",
          lastname: "Doe",
          salary: 2345.67
        }, ];

        grid.data.source = function(request) {
          request.success(mydata.slice(request.index, request.index +
            request.count), mydata.length);
        };


        waitUntil(function() {
          return gridContainsText(grid, "2345.67");
        }, function() {
          var cells = qaLocal(".v-grid-body .v-grid-cell");
          assert.equal(cells[0].innerHTML, "John");
          assert.equal(cells[2].innerHTML, "1234.56");
          assert.equal(cells[3].innerHTML, "Jane");
          assert.equal(cells[4].innerHTML, "Doe");
          done();
        }, done);

      });

      test('data: array type', function(done) {
        grid.columns.push({
          headerHtml: "Salary"
        });

        mydata = [
          ["John", "Doe", 1234.56],
          ["Jane", "Doe", 2345.67],
        ];

        grid.data.source = mydata;

        waitUntil(function() {
          return gridContainsText(grid, "2345.67");
        }, function() {
          var cells = qaLocal(".v-grid-body .v-grid-cell");
          assert.equal(cells[0].innerHTML, "John");
          assert.equal(cells[2].innerHTML, "1234.56");
          assert.equal(cells[3].innerHTML, "Jane");
          assert.equal(cells[4].innerHTML, "Doe");
          done();
        }, done);

      });

      test('data: boolean type', function(done) {
        grid.columns.splice(0, 1);
        grid.selectionMode = "multi";

        waitUntil(function() {
          return qLocal("input[type='checkbox']");
        }, function() {
          var mydata = [
            false,
            true,
          ];

          grid.data.source = function(request) {
            request.success(mydata.slice(request.index, request.index +
              request.count), mydata.length);
          };

          waitUntil(function() {
            return gridContainsText(grid, "false");
          }, function() {
            var cells = qaLocal(".v-grid-body .v-grid-cell");
            assert.equal(cells[3].innerHTML, "true");
            done();
          }, done);
        }, done);

      });

      test('data: string type', function(done) {
        grid.columns.splice(0, 1);
        grid.selectionMode = "multi";

        waitUntil(function() {
          return qLocal("input[type='checkbox']");
        }, function() {
          var mydata = [
            "Lorem",
            "Ipsum",
          ];

          grid.data.source = function(request) {
            request.success(mydata.slice(request.index, request.index +
              request.count), mydata.length);
          };

          waitUntil(function() {
            return gridContainsText(grid, "Lorem");
          }, function() {
            var cells = qaLocal(".v-grid-body .v-grid-cell");
            assert.equal(cells[3].innerHTML, "Ipsum");
            done();
          }, done);
        }, done);

      });

      test('data: non-object types', function(done) {
        var first = grid.columns[0];
        grid.columns.splice(0, 1);
        grid.columns.push(first);
        grid.columns.splice(1, 1);
        grid.grid.setRows(5);


        var mydata = [
          1, 2, null, undefined, 1, "cellsready"
        ];

        grid.data.source = function(request) {
          request.success(mydata.slice(request.index, request.index +
            request.count), mydata.length);
        };

        waitUntil(function() {
          return gridContainsText(grid, "cellsready");
        }, function() {
          var cells = qaLocal(".v-grid-body .v-grid-cell");
          assert.equal(cells[0].innerHTML, "1");
          assert.equal(cells[1].innerHTML, "2");
          assert.equal(cells[2].innerHTML, "");
          assert.equal(cells[3].innerHTML, "");
          assert.equal(cells[4].innerHTML, "1");
          done();
        }, done);

      });

      test('redraw', function(done) {
        function width(e) {
          return pxval(e, 'width');
        }

        function height(e) {
          return pxval(e, 'height');
        }

        function pxval(e, prop) {
          return parseInt(e.ownerDocument.defaultView.getComputedStyle(e).getPropertyValue(prop).replace('px', ''));
        }

        function assertSameDimensions() {
          return width(grid) == width(inner) && height(grid) == height(inner);
        }

        function assertHeightByRows(rows) {
          h = height(inner);
          h1 = headers * thHeight + rows * tdHeight;
          // IE and FF add an aditional pixel to each row
          h2 = h1 + rows + headers;
          return h == h1 || Â h == h2;
        }

        var inner = qLocal("div.v-grid");
        var tbody = qLight('table tbody');
        var thHeight = height(qLocal('thead tr th'));
        var headers = qaLocal('thead tr').length;
        var tdHeight = height(qLocal('tbody tr td'));

        waitUntil(function() {
          return assertSameDimensions();
        }, function() {
          assert.isTrue(assertHeightByRows(2));

          // Increase the number of rows
          tbody.innerHTML += tbody.innerHTML;
          tbody.innerHTML += tbody.innerHTML;
          tbody.innerHTML += tbody.innerHTML;
          tbody.innerHTML += tbody.innerHTML;
          // Maybe DOM.observer polyfill was not loaded
          grid.grid.refresh();
          waitUntil(function() {
            return assertSameDimensions();
          }, function() {
            // grid has a limit of 10 data rows by default
            assert.isTrue(assertHeightByRows(10));

            // Restrict height by rows
            grid.rows = 3;
            waitUntil(function() {
              return assertSameDimensions();
            }, function() {
              assert.isTrue(assertHeightByRows(3));

              // unrestrict height by rows
              grid.rows = 0;
              waitUntil(function() {
                return assertSameDimensions();
              }, function() {
                assert.isTrue(assertHeightByRows(10));

                // Set fixed sizes
                grid.style.width = '300px';
                grid.style.height = '100px';
                waitUntil(function() {
                  return assertSameDimensions();
                }, function() {
                  // Cover all the page
                  grid.style.position = 'absolute';
                  grid.style.width = '100%';
                  grid.style.height = '100%';
                  waitUntil(function() {
                    return assertSameDimensions();
                  }, function() {
                    assert.equal(document.body.clientHeight, height(grid));
                    // For some reason in IE sometimes there is a slight difference of 1 pixels
                    assert.isTrue(Math.abs(document.body.clientWidth - width(grid)) <= 1);
                    // We can have different height for v-grid and the inner grid.
                    // Also we can define more than 10 rows.
                    grid.rows = 12;
                    grid.style.width = '50%';
                    waitUntil(function() {
                      return height(grid) != height(inner);
                    }, function() {
                      assert.equal(width(grid), width(inner));
                      assert.isTrue(assertHeightByRows(12));
                      assert.isFalse(assertSameDimensions());
                      done();
                    }, done);
                  }, done);
                }, done);
              }, done);
            }, done);
          }, done);
        }, done);
      });

      test('editor: getCellEditor and read-only columns', function() {
        grid.columns[0].readOnly = true;

        sinon.spy(editorHandler, "getCellEditor");

        grid.editor.handler = editorHandler;
        grid.editor.enabled = true;
        grid.editor.editRow(0);

        assert.isTrue(editorHandler.getCellEditor.calledOnce);

        editorHandler.getCellEditor.restore();
      });

      var staticSections = ["header", "footer"];

      test('staticsections: non-writable', function() {
        staticSections.forEach(function(section) {
          var original = grid[section];
          grid[section] = undefined;
          assert.equal(grid[section], original);
        });
      });

      test('staticsections: getCell', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {
          var cell = grid[section].getCell(0, 0);
          assert.equal(cell.content, "Name");
          grid.columns[1].name = "foo";
          var cell2 = grid[section].getCell(0, "foo");
          assert.equal(cell2.content, "Value");

          grid[section].addRow(1, [section + "foo", section + "bar"]);

          waitUntil(function() {
            return gridContainsText(grid, section + "foo");
          }, function() {
            assert.equal(grid[section].getCell(1, "foo").content, section + "bar");
            done[section] = true;
          }, done);

        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);

      });

      test('staticsections: cell api', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {
          var cell = grid[section].getCell(0, 0);
          var input = document.createElement("input");
          cell.content = input;

          waitUntil(function() {
            return qLocal(".v-grid-" + section + " .v-grid-cell > input");
          }, function() {
            cell.colspan = 2;

            waitUntil(function() {
              return qaLocal(".v-grid-" + section + " .v-grid-cell")[1].style.display === "none";
            }, function() {
              done[section] = true;
            }, done);
          });
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);

      });

      test('staticsections: cell reference', function() {
        var cell = grid.header.getCell(0, 0);
        var sameCell = grid.header.getCell(0, 0);
        cell.content = "foo";
        assert.equal(sameCell.content, "foo");
      });

      test('staticsections: addRow', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {
          grid[section].addRow();
          var cell = grid[section].getCell(1, 1);
          cell.content = section + "testcontent";

          waitUntil(function() {
            return gridContainsText(grid, section + "testcontent");
          }, function() {
            var cells = qaLocal(".v-grid-" + section + " .v-grid-cell");
            assert.equal(cells[3].innerHTML, section + "testcontent");
            done[section] = true;
          }, done);
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);
      });

      test('staticsections: addRow index', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {

          grid[section].addRow(0);
          var cell = grid[section].getCell(0, 1);
          cell.content = section + "testcontent";

          waitUntil(function() {
            return gridContainsText(grid, section + "testcontent");
          }, function() {
            assert.equal(qaLocal(".v-grid-" + section + " .v-grid-cell")[3].innerHTML, "Value");
            done[section] = true;
          }, done);
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);
      });

      test('staticsections: addRow cellContent', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {

          var input = document.createElement("input");
          grid[section].addRow(0, [0, "foo"]);
          grid[section].addRow(0, [null, input]);

          waitUntil(function() {
            return qLocal(".v-grid-" + section + " .v-grid-cell > input");
          }, function() {
            var cells = qaLocal(".v-grid-" + section + " .v-grid-cell");
            assert.equal(cells[0].innerHTML, "");
            assert.equal(cells[1].firstElementChild, input);
            assert.equal(cells[2].innerHTML, "0");
            assert.equal(cells[3].innerHTML, "foo");
            done[section] = true;
          }, done);
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);

      });

      test('staticsections: removeRow', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {
          grid[section].addRow(1, [0, "testcontent"]);

          waitUntil(function() {
            return gridContainsText(grid, "testcontent");
          }, function() {
            assert.lengthOf(qaLocal(".v-grid-" + section + " .v-grid-row"), 2);

            grid[section].removeRow(0);

            waitUntil(function() {
              return qaLocal(".v-grid-" + section + " .v-grid-row").length === 1;
            }, function() {
              var cells = qaLocal(".v-grid-" + section + " .v-grid-cell");
              assert.equal(cells[1].innerHTML, "testcontent");
              done[section] = true;
            }, done);
          }, done);
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);

      });

      test('staticsections: setRowClassName', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);
        staticSections.forEach(function(section) {
          grid[section].addRow(1);

          grid[section].setRowClassName(0, "first");
          grid[section].setRowClassName(1, "second");

          waitUntil(function() {
            return gridContainsText(grid, "second");
          }, function() {
            var rows = qaLocal(".v-grid-" + section + " .v-grid-row");
            assert.isTrue(rows[0].classList.contains("first"));
            assert.isFalse(rows[0].classList.contains("second"));
            assert.isFalse(rows[1].classList.contains("first"));
            assert.isTrue(rows[1].classList.contains("second"));
            done[section] = true;
          }, done);
        });

        waitUntil(function() {
          return done[staticSections[0]] && done[staticSections[1]];
        }, done, done);
      });

      test('staticsections: hidden', function(done) {
        grid.footer.addRow(0, ["Name", "Value"]);

        assert.isFalse(grid.header.hidden);
        assert.isFalse(grid.footer.hidden);

        grid.header.hidden = true;
        grid.footer.hidden = true;

        waitUntil(function() {
          return qLocal(".v-grid-header").innerHTML === "";
        }, function() {
          assert.equal(qLocal(".v-grid-footer").innerHTML, "");
          done();
        }, done);
      });

      test('staticsections: header.defaultRow', function() {
        assert.equal(grid.header.defaultRow, 0);

        grid.header.defaultRow = 0;

        var setDefaulHeader = function(rowIndex) {
          grid.header.defaultRow = rowIndex;
        };

        expect(setDefaulHeader.bind(this, 1)).to.throw("Row with index 1 does not exist");
        expect(setDefaulHeader.bind(this, -1)).to.throw("Row with index -1 does not exist");

        assert.equal(grid.header.defaultRow, 0);

        grid.header.addRow(0);
        assert.equal(grid.header.defaultRow, 1);

        grid.header.addRow();
        assert.equal(grid.header.defaultRow, 1);

        grid.header.defaultRow = 0;
        assert.equal(grid.header.defaultRow, 0);

      });

      test('DOM: headers & footers', function(done) {
        removeGrid();
        wrapper.innerHTML = "<v-grid><table>" +
          "<thead hidden><tr class='red'><td colspan='2'></td></tr><tr class='pink'><th></th><th></th></tr></thead>" +
          "<tfoot><tr class='foot1'><td colspan='2'></td></tr><tr class='foot2'><td></td><td></td></tr></tfoot>" +
          "</table></v-grid>";
        grid = wrapper.querySelector("v-grid");

        waitUntil(function() {
          return qLocal(".v-grid-body");
        }, function() {
          assert.equal(0, qaLocal("thead tr").length);
          assert.equal(1, qaLocal("tfoot tr.foot1").length);
          assert.equal(1, qaLocal("tfoot tr.foot2").length);
          assert.equal(1, qaLocal("tfoot td[colspan='2']").length);

          qLight("thead").setAttribute('hidden', false)
          waitUntil(function() {
            return qaLocal("thead tr").length > 0;
          }, function() {
            assert.equal(1, qaLocal("thead tr.red").length);
            assert.equal(1, qaLocal("thead tr.pink").length);
            assert.equal(1, qaLocal("thead th[colspan='2']").length);
            done();
          }, done);

        }, done);
      });

      test('DOM: mutation', function(done) {
        waitUntil(function() {
          return qLocal(".v-grid-body");
        }, function() {
          var nrows = qaLocal("tbody tr").length;
          var nheads = qaLocal("thead tr").length;
          qLight("thead").innerHTML += qLight("table thead").innerHTML;
          qLight("tbody").innerHTML += qLight("table tbody").innerHTML;
          assert.equal("Name", qLocal("th").textContent);
          qLight("th").textContent = "foo";
          waitUntil(function() {
            return qLocal("tbody tr") && qaLocal("tbody tr").length == nrows * 2;
          }, function() {
            assert.equal(qaLocal("tbody tr").length, nrows * 2);
            assert.equal(qaLocal("thead tr").length, nheads * 2);
            assert.equal("foo", qLocal("th").textContent);
            done();
          }, done);
        }, done);
      });

    });
  </script>

</body>

</html>
