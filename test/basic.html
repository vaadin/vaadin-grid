<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
  <script src="../../../wct-browser-legacy/browser.js"></script>
  <script type="module" src="../../../@polymer/polymer/lib/utils/render-status.js"></script>
  <script type="module" src="../../../@polymer/test-fixture/test-fixture.js"></script>

  <script type="module" src="./helpers.js"></script>
  <script type="module" src="../vaadin-grid.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <vaadin-grid style="width: 200px; height: 300px;" size="1000">
        <vaadin-grid-column>
          <template>[[index]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <test-fixture id="layout">
    <template>
      <div style="display: flex; width: 300px; height: 300px;">
        <div style="width: 100px; height: 100px; flex-shrink: 0;">Layout sibling</div>
      </div>
    </template>
  </test-fixture>

  <dom-module id="vaadin-custom-grid">
    <script type="module">
import '@polymer/polymer/lib/utils/render-status.js';
import '@polymer/test-fixture/test-fixture.js';
import './helpers.js';
import '../vaadin-grid.js';
import { GridElement } from '../src/vaadin-grid.js';
class MyGridElement extends GridElement {
}
customElements.define('vaadin-custom-grid', MyGridElement);
</script>
  </dom-module>

  <test-fixture id="extended">
    <template>
      <vaadin-custom-grid items='[{"foo": "bar"}]'>
        <vaadin-grid-column path="foo" header="Foo"></vaadin-grid-column>
      </vaadin-custom-grid>
    </template>
  </test-fixture>

  <script type="module">
import { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';
import '@polymer/test-fixture/test-fixture.js';
import './helpers.js';
import '../vaadin-grid.js';
import { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';
import { Base } from '@polymer/polymer/polymer-legacy.js';
describe('basic features', () => {
  let grid;

  const firstVisibleIndex = grid => grid.__scroller._first;
  const physicalAverage = grid => grid.__scroller.layout.itemSize.height;
  const scroll = (grid, x, y) => grid.$.table.scroll(x, y);
  const scrollToIndex = (grid, index) => grid.__scroller.layout.scrollToIndex(index);

  beforeEach(() => {
    grid = fixture('default');
    grid.dataProvider = infiniteDataProvider;
    flushGrid(grid);
  });

  describe('toggle attribute', () => {
    let node;

    beforeEach(() => {
      node = {};
      node.setAttribute = sinon.spy();
      node.removeAttribute = sinon.spy();
    });

    it('should set attribute', () => {
      node.hasAttribute = () => false;
      grid._toggleAttribute('foo', true, node);
      expect(node.setAttribute.called).to.be.true;
    });

    it('should not re-set attribute', () => {
      node.hasAttribute = () => true;
      grid._toggleAttribute('foo', true, node);
      expect(node.setAttribute.called).to.be.false;
    });

    it('should remove attribute', () => {
      node.hasAttribute = () => true;
      grid._toggleAttribute('foo', false, node);
      grid._toggleAttribute('foo', '', node);
      grid._toggleAttribute('foo', undefined, node);
      expect(node.removeAttribute.callCount).to.equal(3);
    });

    it('should not re-remove attribute', () => {
      node.hasAttribute = () => false;
      grid._toggleAttribute('foo', false, node);
      grid._toggleAttribute('foo', '', node);
      grid._toggleAttribute('foo', undefined, node);
      expect(node.removeAttribute.called).to.be.false;
    });
  });

  it('should notify `size` property', done => {
    expect(grid.size).not.equal(10);

    listenOnce(grid, 'size-changed', () => {
      expect(grid.size).equal(10);
      done();
    });
    grid.size = 10;
  });

  it('check physical item heights', () => {
    const physicalItems = Array.from(grid.$.items.children);
    const rowHeight = physicalItems[0].offsetHeight;

    physicalItems.forEach(item => expect(item.offsetHeight).to.be.closeTo(rowHeight, 1));
  });

  it('check visible item count', () => {
    grid.size = 10;
    flushGrid(grid);
    expect(Array.from(grid.$.items.children).filter(tr => tr.style.display !== 'none').length).to.eql(10);
  });

  it('first visible index', () => {
    expect(firstVisibleIndex(grid)).to.equal(0);
    scroll(grid, 0, physicalAverage(grid) * 50);
    grid._scrollHandler();
    expect(firstVisibleIndex(grid)).to.equal(50);
    scrollToIndex(grid, 0);
    grid._scrollHandler();
    expect(firstVisibleIndex(grid));
  });

  it('last visible index', () => {
    const actualHeight = grid._physicalAverage;
    scrollToIndex(grid, 2);
    expect(grid.lastVisibleIndex, Math.ceil(((grid._scrollTop + grid.offsetHeight) / actualHeight) - 1));
  });

  it('Should change the opacity of cell content in loading rows from 1 to 0 and back', () => {
    const firstRow = grid.shadowRoot.querySelector('#items [part~="row"]');
    const cellContent = getBodyCellContent(grid, 0, 0);

    expect(window.getComputedStyle(cellContent).opacity).to.eql('1');

    firstRow.setAttribute('loading', '');

    expect(window.getComputedStyle(cellContent).opacity).to.eql('0');

    firstRow.removeAttribute('loading', '');

    expect(window.getComputedStyle(cellContent).opacity).to.eql('1');
  });


  it('scroll to index', () => {
    grid.size = 100;

    scrollToIndex(grid, 30);
    expect(grid.firstVisibleIndex).to.equal(30);

    scrollToIndex(grid, 0);
    expect(grid.firstVisibleIndex).to.equal(0);

    scrollToIndex(grid, 99);

    const rowHeight = getFirstVisibleItem(grid).offsetHeight;
    const viewportHeight = grid.offsetHeight;
    const itemsPerViewport = viewportHeight / rowHeight;

    expect(grid.firstVisibleIndex, Math.floor(grid.size - itemsPerViewport));
    scrollToIndex(grid, 0);
    // make the height of the viewport same as the height of the row
    // and scroll to the last item
    grid.style.height = (grid._physicalItems[0].offsetHeight - 2) + 'px';
    grid.notifyResize();
    scrollToIndex(grid, 99);
    expect(grid.firstVisibleIndex).to.equal(99);
  });

  it('scroll to top', () => {
    scrollToIndex(grid, 99);
    grid.scroll(0, 0);
    expect(grid._scrollTop).to.equal(0);
  });

  it('scroll to a given scrollTop', () => {
    scrollToIndex(grid, 99);
    grid.scroll(0, 500);
    expect(grid.$.table.scrollTop).to.equal(500);
  });

  it('should not scroll when size changes', () => {
    scrollToIndex(grid, 99);
    const top = grid.$.table.scrollTop;

    grid.size += 1;

    expect(grid.$.table.scrollTop).to.eql(top);
    expect(top).to.be.greaterThan(0);
  });

  it('reset items', () => {
    grid.size = 100;

    expect(getCellContent(getFirstVisibleItem(grid)).textContent).to.equal('0');

    grid.size = 0;
    expect(getFirstVisibleItem(grid), null);

    grid.size = 100;
    expect(getCellContent(getFirstVisibleItem(grid)).textContent).to.equal('0');
  });

  it('reorder rows', () => {
    grid.size = 1000;
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144].forEach(steps => {
      grid.$.table.scrollTop = 5000 + grid._physicalAverage * steps;
      grid._scrollHandler();
      grid._debounceScrolling.flush();
      // Expect the physical rows to be in order after scrolling
      const rows = dom(grid.$.items).querySelectorAll('tr');

      rows.forEach((row, index) => {
        if (index > 0) {
          expect(row.index).to.equal(rows[index - 1].index + 1);
        }
      });
    });
  });

  it('reorder should not affect light dom', () => {
    grid.size = 1000;
    const wrappers = dom(grid).querySelectorAll('vaadin-grid-cell-content');

    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144].forEach(steps => {
      grid.$.table.scrollTop = 5000 + grid._physicalAverage * steps;
      grid._scrollHandler();
      grid._debounceScrolling.flush();

      const newWrappers = dom(grid).querySelectorAll('vaadin-grid-cell-content');
      // Expect the light dom order unchanged
      expect(newWrappers).to.eql(wrappers);
    });
  });

  it('should not throw after setting size to 0', () => {
    grid.size = 1000;
    scrollToEnd(grid);
    expect(() => {
      grid.size = 0;
      flushGrid(grid);
    }).not.to.throw();
  });

  // The following could not be tested if window is not focused.
  if (!window.document.hasFocus()) {
    // Try to get window focus.
    window.top && window.top.focus();
    window.focus();
  }
  (window.document.hasFocus() ? it : it.skip)('reorder should keep focused row', () => {
    grid.size = 1000;
    getCell(grid, 10).focus();
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144].forEach(steps => {
      const activeElement = grid.shadowRoot.activeElement;
      grid.$.table.scrollTop = 5000 + grid._physicalAverage * steps;
      grid._scrollHandler();
      grid._debounceScrolling.flush();

      // Expect the physical rows to be in order after scrolling
      const rows = dom(grid.$.items).querySelectorAll('tr');

      rows.forEach((row, index) => {
        if (index > 0) {
          expect(row.index).to.equal(rows[index - 1].index + 1);
        }
      });

      // Safari 9 needs polyfilled `_activeElement` to return correct node
      const docActiveElement = document._activeElement !== undefined ? document._activeElement : document.activeElement;

      expect(docActiveElement).to.equal(grid);
      expect(grid.shadowRoot.activeElement).to.equal(activeElement);
    });
  });

  const describeMissingImportWarning = (elementName) => {
    describe(`import warning for ${elementName}`, () => {
      it('should not warn if not in use', () => {
        sinon.stub(console, 'warn');

        grid._observer && grid._observer.flush && grid._observer.flush();
        grid._debouncerCheckImports.flush();
        expect(console.warn.called).to.be.false;

        console.warn.restore();
      });

      it('should warn once if in use', () => {
        sinon.stub(console, 'warn');

        grid.appendChild(document.createElement(elementName));
        grid.appendChild(document.createElement(elementName));
        grid._observer && grid._observer.flush && grid._observer.flush();
        grid._debouncerCheckImports.flush();

        expect(console.warn.callCount).to.equal(1);

        console.warn.restore();
      });

      it('should warn after adding', () => {
        sinon.stub(console, 'warn');

        grid._observer && grid._observer.flush && grid._observer.flush();
        grid._debouncerCheckImports.flush();

        grid.appendChild(document.createElement(elementName));
        grid._observer && grid._observer.flush && grid._observer.flush();
        grid._debouncerCheckImports.flush();

        expect(console.warn.called).to.be.true;

        console.warn.restore();
      });

      it('should not warn for present import', (done) => {
        if (window.isV2()) {
          Base.importHref(`../${elementName}.html`, () => {
            sinon.stub(console, 'warn');

            grid.appendChild(document.createElement(elementName));
            grid._observer && grid._observer.flush && grid._observer.flush();
            grid._debouncerCheckImports.flush();

            expect(console.warn.called).to.be.false;
            console.warn.restore();
            done();
          });
        } else {
          // importHref doesn't work with modulizer -> p3 yet, skip the test on P3
          done();
        }
      });

    });
  };

  describeMissingImportWarning('vaadin-grid-sorter');
  describeMissingImportWarning('vaadin-grid-tree-toggle');

  it('should have flex: 1 1 auto style', () => {
    expect(parseInt(window.getComputedStyle(grid).getPropertyValue('flex-shrink'))).to.equal(1);
    expect(parseInt(window.getComputedStyle(grid).getPropertyValue('flex-grow'))).to.equal(1);
    expect(window.getComputedStyle(grid).getPropertyValue('flex-basis')).to.equal('auto');
  });

  describe('flex child', () => {
    let layout;

    beforeEach(() => {
      layout = fixture('layout');
      grid.style.removeProperty('width');
      grid.style.removeProperty('height');
      layout.appendChild(grid);
      flushGrid(grid);
    });

    it('should have 400px height by default', () => {
      expect(grid.getBoundingClientRect().height).to.be.closeTo(400, 1);
    });

    describe('in horizontal layout', () => {
      it('should stretch width', () => {
        expect(grid.getBoundingClientRect().width).to.be.closeTo(200, 1);
        expect(grid.$.scroller.getBoundingClientRect().width).to.be.closeTo(200 - 2, 1);
      });

      it('should not stretch height', () => {
        expect(grid.getBoundingClientRect().height).to.be.closeTo(400, 1);
        expect(grid.$.scroller.getBoundingClientRect().height).to.be.closeTo(400 - 2, 1);
      });
    });

    describe('in vertical layout', () => {
      beforeEach(() => {
        layout.style.flexDirection = 'column';
      });

      it('should stretch width', () => {
        expect(grid.getBoundingClientRect().width).to.be.closeTo(300, 1);
        expect(grid.$.scroller.getBoundingClientRect().width).to.be.closeTo(300 - 2, 1);
      });

      it('should stretch height', () => {
        expect(grid.getBoundingClientRect().height).to.be.closeTo(200, 1);
        expect(grid.$.scroller.getBoundingClientRect().height).to.be.closeTo(200 - 2, 1);
      });
    });
  });
});

describe('extended', () => {
  let grid;

  beforeEach(() => grid = fixture('extended'));

  it('child column should be able to find host grid', () => {
    expect(grid.querySelector('vaadin-grid-column')._grid).to.be.equal(grid);
  });
});
</script>

</body>

</html>
